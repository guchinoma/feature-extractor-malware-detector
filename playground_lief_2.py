import lief
from ConfigParser import SafeConfigParser

import re

import os
import os.path

from capstone import *

def main():
    config = SafeConfigParser()
    config.read('./config/main.conf')
    path = config.get('main', 'malware_directory')
    binary_list = os.listdir(path)

    full_path_list = []
    for i in binary_list:
        full_path_list.append(os.path.join(path, i))

    for i in full_path_list:
        print i

    for binary in full_path_list:

        b = lief.PE.parse(binary)
        txt_section = b.get_section(".text")
        contents = txt_section.content
        contents_hex = []

        for i in contents:
            binary_one_letter_list = ["x0", "x1", "x2", "x3", "x4", "x5", 
                                      "x6", "x7", "x8", "x9", "xa", "xb", 
                                      "xc", "xd", "xe", "xf"]
            data = str(hex(i))
            data = re.sub("L", "", data)
            data = re.sub("0x", "x", data)
            for j in binary_one_letter_list:
                if data == j:
                    data = re.sub("x", "x0", data)
                else:
                    continue
            contents_hex.append(data)

        str_contents_hex = "\\".join(contents_hex)

        # make files of binary codes in ./log/static/malicious directory
        binary_itself = re.sub(path, "", binary)
        binary_file_name = config.get('main', 'log_directory_malicious') + binary_itself + ".txt"

        dictionary_of_iat = {}
        for imported_library in b.imports:
            for func in imported_library.entries:
                if not func.is_ordinal:
                    dictionary_of_iat[func.name] = hex(func.iat_address)
                        
                else:
                    continue

        #print dictionary_of_iat

        for k, v in dictionary_of_iat.items():
            #print "type of str_contents_hex is " + str(type(str_contents_hex))
            address_with_L = str(v)

            print "address_with_L is " + address_with_L

            address_little_endien = "\\\\x" + address_with_L[4] + address_with_L[5] + "\\\\x" + address_with_L[2] + address_with_L[3]

            print "address_little_endien of " + k + " is " + address_little_endien

            check = str_contents_hex.find(address_little_endien)
            if check == []:
                print "There is no address_little_endien of " + k
                print "Will be abort the procedure of " + k + "\n"
                continue
                

            else:
                print "There is address_little_endien of " + k
                #str_contents_hex_little_endian = re.sub(address_little_endien, k, str_contents_hex)
                letter = "\\\\" + k
                p = re.compile(address_little_endien)
                str_contents_hex = p.sub(letter, str_contents_hex)
                #list_of_subn = p.subn(k, str_contents_hex)
                #for i in list_of_subn:
                    #str(i)
                #string_list = "->".join(list_of_subn)
                #with open("log_of_subn", "w") as f:
                    #f.write(binary)
                    #f.write("\n")
                    #f.write(string_list)

                #print binary 
                #print list_of_subn[1]
                print "Done replacing address with " + k +"\n"
                continue
                

            
        with open(binary_file_name, "w") as f:

            # getting dictionary of func and address of iat

            f.write(str_contents_hex)

        

        # getting iat table together with its address

        

        #with open(binary_file_name, "w") as f:
            #ib = b.optional_header.imagebase
            #print ib

            #md = Cs(CS_ARCH_X86, CS_MODE_32)

            #for j in md.disasm(data, ib):
                                # (error_4)
                # all stuffs in opcodes are just number, not str, so
                # you should replace the type of it using str()

                # address should be converted into the 0xXXXX

                #opcode = []
                #opcode.append(hex(j.address))
                #opcode.append(str(j.mnemonic))
                #opcode.append(str(j.op_str))
                #opcode_list = " ".join(opcode)
                
                #for name_of_iat, address_of_iat in dict_of_iat.items():
                    #address = str(address_of_iat)
                    #print name_of_iat, address_of_iat
                    #if name_of_iat is None:
                        #break
                    #else:
                        #re.sub(address, name_of_iat, opcode_list)

                #for k in opcode_list:
                    #f.write(k)
                #f.write('\n')
                
                #opcode = str(j.mnemonic) + '\t'
                #f.write(opcode)


            #f.write('\n\n')



if __name__ == '__main__':
    main()