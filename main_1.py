###################################################################
# The goal of this is put assembly files consisting of not only
# every single operational code, but also Windows API calls
# called in the assemble file. This aims to put a result resembling 
# that of IDA pro.
###################################################################

from ConfigParser import SafeConfigParser
from capstone import *
import pefile
import os
import os.path

import re

#import utils

#import RF_train

def convert_malware_to_txt_data(malware_list):
    config = SafeConfigParser()
    for malware in malware_list:
        if malware is ".DS_Store":
            print "aborted for this is .DS_Store"
            break
        malware_without_ext = re.sub(".bin", "", malware)
        filename = malware_without_ext + ".txt"
        print "now disas-ing " + filename
        #path_of_log = config.get('log', 'log_directory_malicious')
        path_of_log = "./log/static/malicious"
        print "path_of_log is " + path_of_log
        filename_and_path = os.path.join(path_of_log, filename)
        with open(filename_and_path, 'w') as f:
            #each_malware_path = os.path.join(config.get('log', 'log_directory_malicious'), malware)
            each_malware_path = os.path.join("./malicious", malware)
            print "each_malware_path is " + each_malware_path 
            pe = pefile.PE(each_malware_path)

            #dict_of_iat = {}

            #for entry in pe.DIRECTORY_ENTRY_IMPORT:
                #for imp in entry.imports:
                    #dict_of_iat[imp.name] = hex(imp.address)

            #print full_path, "\n", dict_of_iat, "\n"

            ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            print "ep is " + hex(ep)
            ep_ava = ep + pe.OPTIONAL_HEADER.ImageBase
            print "ep with imagebase is " + hex(ep_ava)
            data = pe.get_memory_mapped_image()[ep:]

            md = Cs(CS_ARCH_X86, CS_MODE_32)

            for j in md.disasm(data, ep_ava):
                # (error_4)
                # all stuffs in opcodes are just number, not str, so
                # you should replace the type of it using str()

                # address should be converted into the 0xXXXX

                opcode = []
                opcode.append(hex(j.address))
                opcode.append(str(j.mnemonic))
                opcode.append(str(j.op_str))
                opcode_list = " ".join(opcode)
                
                #for name_of_iat, address_of_iat in dict_of_iat.items():
                    #address = str(address_of_iat)
                    #print name_of_iat, address_of_iat
                    #if name_of_iat is None:
                        #break
                    #else:
                        #re.sub(address, name_of_iat, opcode_list)

                for k in opcode_list:
                    f.write(k)
                f.write("\n")


# add some assembly of address lower than entry address.
#def add_outside_assemble_file(log_list):
    


def address_convert_to_iat_function(log_list):

    for log in log_list:
        malware_name = re.sub("txt", "bin", log)
        malware_name_full_path = os.path.join("./malicious", malware_name)
        print "malware_name_full_path is " + malware_name_full_path
        pe = pefile.PE(malware_name_full_path)
        pe.parse_data_directories()
        log = os.path.join('./log/static/malicious', log)
        print "The log is " + log

        dictionary_of_iat = {}
        for i in pe.DIRECTORY_ENTRY_IMPORT:
            #print i.dll
            for j in i.imports:
                #print '\t', j.name
                dictionary_of_iat[hex(j.address)] = str(j.name)
        print "Done\n"

        print dictionary_of_iat
        with open(log) as f:
            lines = f.readline()
            for address, value in dictionary_of_iat.items():
                print "ad and va is " + address + "\t" + value
                re.sub(address, str(value), lines)
                #print "Done the first loop\n"
        print "End\n"




def main():

    config = SafeConfigParser()
    config.read('./config/main.conf')

    # get all malware in the malware directory in variable "directory_of_malware"
    # as a type of list
    directory_name = config.get('main', 'malware_directory')
    directory_of_malware = os.listdir(directory_name)

    #for i in directory_of_malware:
        #print i

    #directory_of_malware_with_full_path = []

    #for malware in directory_of_malware:
        #name = os.path.join(directory_name, malware)
        #directory_of_malware_with_full_path.append(name)
    ## for checking
    #for malware in directory_of_malware_with_full_path:
        #print "the name is " + malware
    
    convert_malware_to_txt_data(directory_of_malware)
    # now have all md hashes of malware in directory_of_malware list and 
    # malware with full path in directory_of_malware_with_full_path

    logs = os.listdir('./log/static/malicious')
    for i in logs:
        print "the log is " + i + "\t"
    
    address_convert_to_iat_function(logs)


if __name__ == '__main__':
    main()