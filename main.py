###################################################################
# The goal of this is put assembly files consisting of not only
# every single operational code, but also Windows API calls
# called in the assemble file. This aims to put a result resembling 
# that of IDA pro.
###################################################################

from ConfigParser import SafeConfigParser
from capstone import *
import pefile
import os
import os.path

import re

#import utils

#import RF_train

def retrieve_opcodes_and_labels(directory_name, text_file):
    config = SafeConfigParser()
    config.read('./config/main.conf')

    # (error_2)
    # in the def-function, you have got to set variable of SafeConfigParser() 
    # and read with '.read()' method like below

    with open(text_file, "w") as f:
        if directory_name == config.get('main', 'malware_directory'):
            f.write('Malicious\n\n\n')

        else:
            f.write('Benign\n\n\n')

        list_of_sotware = os.listdir(directory_name)
        
        # (error_3)
        # not 'os.path.listdir', it's 'os.listdir'

        for i in list_of_sotware:
            full_path = os.path.join(directory_name, i)
            f.write(full_path)
            f.write('\n')
            pe = pefile.PE(full_path)

            #dict_of_iat = {}

            #for entry in pe.DIRECTORY_ENTRY_IMPORT:
                #for imp in entry.imports:
                    #dict_of_iat[imp.name] = hex(imp.address)

            #print full_path, "\n", dict_of_iat, "\n"

            ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            #print hex(ep)
            ep_ava = ep + pe.OPTIONAL_HEADER.ImageBase
            #print hex(ep_ava)
            data = pe.get_memory_mapped_image()[ep:]

            md = Cs(CS_ARCH_X86, CS_MODE_32)

            for j in md.disasm(data, ep_ava):
                # (error_4)
                # all stuffs in opcodes are just number, not str, so
                # you should replace the type of it using str()

                # address should be converted into the 0xXXXX

                opcode = []
                opcode.append(hex(j.address))
                opcode.append(str(j.mnemonic))
                opcode.append(str(j.op_str))
                opcode_list = " ".join(opcode)
                
                #for name_of_iat, address_of_iat in dict_of_iat.items():
                    #address = str(address_of_iat)
                    #print name_of_iat, address_of_iat
                    #if name_of_iat is None:
                        #break
                    #else:
                        #re.sub(address, name_of_iat, opcode_list)

                for k in opcode_list:
                    f.write(k)
                f.write('\n')
                
                #opcode = str(j.mnemonic) + '\t'
                #f.write(opcode)


            f.write('\n\n')

def n_gram(number, list_of_opcodes):
    list_of_letter_ngram = []
    number_of_letter = len(list_of_opcodes)
    # if number is set 2, meaninig 2-gram, number_to_decrement will be set 1, for 2 - 1 = 1, 
    # then, decrement number_of_letter using number_to_decrement, which stands for
    # the limitation of this loop
    number_to_decrement = number - 1

    for k in xrange(number_of_letter - number_to_decrement):
        tmp_ngram = []
        for l in len(number):
            tmp_ngram.append(list_of_opcodes[l])
        for m in xrange(len(tmp_ngram)):
            list_of_letter_ngram.append(tmp_ngram[m])

    return list_of_letter_ngram


# Try to implement a function that performs execution of binary 
# in cuckoo sandbox.
#def execute_in_cuckoo_sandbox(binary):

def matching_address_to_iat_table(filename):
    with open(filename) as f:
        lines = f.readlines()
        for line in lines:
            re.match()


def main():

    config = SafeConfigParser()
    config.read('./config/main.conf')

    #b = config.get('main', 'benign_txt')
    m = config.get('main', 'malicious_txt')

    #retrieve_opcodes_and_labels(config.get('main', 'benign_directory'), m)
    #retrieve_opcodes_and_labels(config.get('main', 'benign_directory'), b)
    retrieve_opcodes_and_labels(config.get('main', 'malware_directory'), m)
    # (error_1)
    # don`t recongnise the second argument like "benign.txt"
    
    #convert_address_to_func_in_iat()

if __name__ == '__main__':
    main()