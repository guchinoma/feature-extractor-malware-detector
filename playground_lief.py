import lief
from ConfigParser import SafeConfigParser

import re

import os
import os.path

from capstone import *

def main():
    config = SafeConfigParser()
    config.read('./config/main.conf')
    path = config.get('main', 'malware_directory')
    binary_list = os.listdir(path)

    full_path_list = []
    for i in binary_list:
        full_path_list.append(os.path.join(path, i))

    for i in full_path_list:
        print i

    for binary in full_path_list:
        binary_one_letter_list = ["\\0x0", "\\0x1", "\\0x2", "\\0x3", "\\0x4", "\\x05", 
                                  "\\0x6", "\\0x7", "\\0x8", "\\0x9", "\\0xa", "\\0xb", 
                                  "\\0xc", "\\0xd", "\\0xe", "\\0xf"]
        b = lief.PE.parse(binary)
        txt_section = b.get_section(".text")
        contents = txt_section.content

        contents_hex = []

        # gathering binary code in list object
        for i in contents:
            data = "\\" + str(hex(i))
            data = re.sub("L", "", data)
            data = re.sub("\\0x", "\\x", data)
            for j in binary_one_letter_list:
                if data == j:
                    data = data + "0"
                else:
                    continue
            contents_hex.append(data)

        str_contents_hex = "".join(contents_hex)
        str_contents_hex = re.sub(r"\\0", r"\\", str_contents_hex)

        binary_itself = re.sub(path, "", binary)


        # make files of binary codes in ./log/static/malicious directory
        binary_file_name = config.get('main', 'log_directory_malicious') + binary_itself + ".txt"

        dictionary_of_iat = {}
        for imported_library in b.imports:
            for func in imported_library.entries:
                if not func.is_ordinal:
                    dictionary_of_iat[func.name] = hex(func.iat_address)
                        
                else:
                    continue

        print dictionary_of_iat

        for k, v in dictionary_of_iat.items():
            address_with_L = str(v)

            address_little_endien = "\\x" + address_with_L[4] + address_with_L[5] + "\\x" + address_with_L[2] + address_with_L[3]

            print "address_little_endien of " + k + " is " + address_little_endien

            check = str_contents_hex.find(address_little_endien)
            if check == -1:
                print "There is no address_little_endien of " + k

            else:
                print "There is address_little_endien of " + k

            str_contents_hex_little_endian = re.sub(address_little_endien, k, str_contents_hex)

        with open(binary_file_name, "w") as f:

            # getting dictionary of func and address of iat

            f.write(str_contents_hex_little_endian)

        

        # getting iat table together with its address

        

        #with open(binary_file_name, "w") as f:
            #ib = b.optional_header.imagebase
            #print ib

            #md = Cs(CS_ARCH_X86, CS_MODE_32)

            #for j in md.disasm(data, ib):
                                # (error_4)
                # all stuffs in opcodes are just number, not str, so
                # you should replace the type of it using str()

                # address should be converted into the 0xXXXX

                #opcode = []
                #opcode.append(hex(j.address))
                #opcode.append(str(j.mnemonic))
                #opcode.append(str(j.op_str))
                #opcode_list = " ".join(opcode)
                
                #for name_of_iat, address_of_iat in dict_of_iat.items():
                    #address = str(address_of_iat)
                    #print name_of_iat, address_of_iat
                    #if name_of_iat is None:
                        #break
                    #else:
                        #re.sub(address, name_of_iat, opcode_list)

                #for k in opcode_list:
                    #f.write(k)
                #f.write('\n')
                
                #opcode = str(j.mnemonic) + '\t'
                #f.write(opcode)


            #f.write('\n\n')



if __name__ == '__main__':
    main()